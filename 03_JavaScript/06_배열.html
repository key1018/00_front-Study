<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>06_배열</title>

    <style>
        .area{
            border:1px solid black;
            width: 300px;
            height:300px;
        }
    </style>

</head>

<body>
    
    <h1>배열</h1>
    <p>
        배열 변수 선언시 별도의 자료형 지정이 없기 때문에 <br>
        어떤 자료형의 값들이든 다 하나의 배열공간에 담을 수 있음(자료형의 제약X),
        크기에 제약도 없음 (자바스크립트의 배열 == 자바에서의 ArrayList와 유사)
        <!-- 자바의 경우 배열을 선택할 때 int형이면 int만 담을 수 있고, 크기의 제약도 있지만,
             자바스크립트는 자료형과 크기에 대한 제약이 없다!! -->
    </p>
    <button onclick="arrayTest1();">배열 확인 클릭</button>
    <div class="area" id="area1"></div>

    <script>

        function arrayTest1() {

            const divEl = document.getElementById('area1');
            const arr = ["홍길동","서울",20,true,[1,2,3]]; // 자바스크립트에서의 배열(자료형,크기 제약x)
            // 배열안에 배열도 담을 수 있음 => type : object

            console.log(arr);
            console.log(arr[2]);
            console.log(arr[4][1]); // 배열안에 배열의 인덱스를 통해서도 접근가능

            divEl.innerHTML = "배열 전체 출력 : " + arr + "<br>"; // 배열 전체 출력
            divEl.innerHTML += "arr[1] : " + arr[1] + "<br>"; // 배열의 1번 인덱스 출력
            divEl.innerHTML += "arr[4][2] : " + arr[4][2] + "<br>"; // 배열의 4번 인덱스에 있는 또다른 배열의 2번 인덱스 출력 => 배열안에 배열의 인덱스를 통해서도 접근가능

            divEl.innerHTML += "<br> for each문 <br>";
            // 각 인덱스에 담긴 배열 값 출력
            // 1) for loop문
            for(let i = 0; i < arr.length; i++){
                divEl.innerHTML += "arr[" + i + "] : " + arr[i] + "<br>"; 
            }

            divEl.innerHTML += "<br>for in문 <br>";

            // 2) for in문 (자바에서의 for each문과 유사)
            // for(let 변수 in 순차적으로접근할 배열)
            for(let i in arr) {  // i = 0 => i = 2 => .... => 1 = 마지막인덱스수
                divEl.innerHTML += "arr[" + i + "] : " + arr[i] + "<br>"; 
            }

        }

    </script>

    <hr>

    <h3>* 배열의 선언</h3>
    <button onclick="arrayTest2();">배열 선언 확인하기</button>

    <script>

        function arrayTest2() {

            // 임의의 배열 선언
            const arr1 = new Array(); // 생성자함수 => 크기지정X
            const arr2 = new Array(3); // 크기지정한 함수 => console창에서보면 값을 대입안했기 때문에 empty로 나옴
            const arr3 = []; // 빈 배열 => 크기 : 0 

            // arr1에 값 대입
            arr1[0] = "사과";
            arr1[1] = "바나나";
            arr1[12] = "파인애플"; 
            // arr1의 길이 : 13 => 중간에 2번~11번 인덱스를 건너띄고 12번부터 값을 넣어도 인덱스가 생성됨 
            // 2~11번 인덱스는 empty

            console.log(arr1);

            // arr2에 값 대입 (크기 : 3)
            arr2[0]="대한민국";
            arr2[1]="미국";
            arr2[2]="프랑스"; 
            // 크기 3을 초과해서 입력해도 오류발생 없이 초과한 만큼 배열의 크기가 늘어남
            arr2[3]="캐나다";
            arr2[4]="싱가폴";
            
            console.log(arr2);

            // 배열선언과 동시에 초기화
            const arr4 = new Array("자동차", "오토바이", "보트");
            console.log(arr4);
            
            // 대괄호를 이용해서 바로 값 담기
            const arr5 = ["아메리카노", "카페라떼", "레몬에이드"];
            console.log(arr5);

        }

    </script>

    <hr>

    <h3>* 배열과 관련된 메소드</h3>
    <h4>1) 배열.indexOf(찾고자하는요소) : 배열에서 해당 요소가 위치해있는 인덱스 반환</h4>

    <div class="area" id="area2"></div>
    <button onclick="indexOfTest();">배열 인덱스 확인하기</button>

    <script>

        function indexOfTest() {

            // div요소에 값을 담기위한 변수 선언
            const divEl = document.getElementById('area2');

            // 임의의 배열 선언
            const arr = ['사과', '딸기', '바나나', '파인애플', '수박'];

            // // prompt를 통해 사용자에게 찾고자하는 과일명 입력받기
            // const fruit = prompt("찾고하는 과일명 입력");

            // // indexOf을 통해 찾고자하는 요소의 인덱스 위치 찾기
            // const index = arr.indexOf(fruit); // 배열에 찾고자하는 요소가 없는 경우 : -1 출력

            // const index = arr.indexOf(prompt("찾고자하는 과일명 입력"));

            // if(index == -1 ) { // 찾지 못했을 경우 : -1
            //     divEl.innerHTML = "찾고자하는 '" + fruit + "' 과일은 없습니다.";
            // } else { // 찾은 경우 : 인덱스 위치 나타남
            //     divEl.innerHTML = "찾고자하는 '" + fruit + "' 은(는)" + index + "번째 인덱스에 위치해있습니다.";
            // }

            // 자바스크립트에서의 두 값이 동일한지 비교하는 연산자
            console.log(1==1); // true
            console.log(1 == "1"); // true => 동등연산자(자료형과 상관없이 실제값만 일치해도 true)
            console.log(1 === "1"); // false => 일치연산자(자료형, 실제값 모두 일치해야 true)
            console.log("1" === "1"); // true

        }

    </script>

<hr>

    <h4>2) 배열.concat(배열, 배열, .. ) : 배열에 여러개의 배열을 결합하고자 할 때</h4>

    <div class="area" id="area3"></div>
    <button onclick="concatTest();">배열 결합 확인</button>

    <script>

        function concatTest() {

            // div요소에 담기
            const divEl = document.getElementById('area3');

            // 임의의 배열 생성
            const arr1 = [1,2,3];
            const arr2 = ['a','b','c'];
            const arr3 = ['홍길동', '김말똥', '이적삼'];

            // 기존의 배열들 출력
            divEl.innerHTML = "기존 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "기존 arr2 : " + arr2 + "<br>";
            divEl.innerHTML += "기존 arr3 : " + arr3 + "<br>";

            // concat요소를 활용하여 배열결합하기
            divEl.innerHTML += "<br>arr1을 기준으로 배열들 합침 : " + arr1.concat(arr2,arr3) + "<br>";
            divEl.innerHTML += "arr2을 기준으로 arr3, arr1 순서대로 합침 : " + arr2.concat(arr3,arr1) + "<br>";
            
            // 합친 후의 arr1, arr2 출력하기
            divEl.innerHTML += "<br>합친 후 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "합친 후 arr2 : " + arr2 + "<br>"; 
            // concat은 일시적으로 합치는 요소로 원본 손상x
            // 즉, 원본 배열에 영향을 끼치는 메소드가 아님 => 배열들을 합쳐서 새로운 배열로 반환

            // concat내부에 새로운 배열을 생성하여 추가도 가능하다
            divEl.innerHTML += "<br>arr3에 새로운 배열 추가하여 생성 : " + arr3.concat(arr1,["딸기", "바나나", "포도"]);

        }

    </script>

    <hr>

    <h4>3) 배열.reverse() : 배열에 담겨있는 값들을 역순으로 바꿔주는 메소드</h4>

    <div class="area" id="area4"></div>
    <button onclick="reverseTest();">배열 역순 확인하기</button>

    <script>

        function reverseTest() {

            // div요소에 담기
            const divEl = document.getElementById("area4");

            // 임의의 배열 생성
            const arr1 = [1,2,3,4,5,6];
            const arr2 = ['홍길동', '김말똥', '이적삼', '구말자', '가나영'];

            // 기존 배열 구조 출력
            divEl.innerHTML += "기존 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "기존 arr2 : " + arr2 + "<br>";

            // reverse요소를 활용하여 배열을 역순으로 정렬하기
            divEl.innerHTML += "<br>arr1의 역순 : " + arr1.reverse() + "<br>";
            divEl.innerHTML += "arr2의 역순 : " + arr2.reverse() + "<br>";

            // 역순 후의 배열들 출력
            divEl.innerHTML += "<br>역순 후의 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "역순 후의 arr2 : " + arr2 + "<br>";
            // 배열들이 역순으로 고정되어서 나열됨
            // reverse는 원본배열에 영향을 끼치는 메소드 => 원래의 배열 순서도 돌아가고싶으면 다시 reverse를 해주어야함!
        
            // 원상복귀
            divEl.innerHTML += "<br>원상복귀 arr1 : " + arr1.reverse() + "<br>";
            divEl.innerHTML += "원상복귀 arr2 : " + arr2.reverse() + "<br>";

        }

    </script>

    <hr>

    <h4>4) 배열.sort() : 배열 안에 담긴 값들을 오름차순으로 정렬시켜주는 메소드(내림차순은 안됨)</h4>

    <div class="area" id="area5"></div>
    <button onclick="sortTest();">오름차순 확인</button>

    <script>

        function sortTest() {

            // div요소에 담기
            const divEl = document.getElementById('area5');

            // 임의의 배열 생성
            const arr1 = [1,7,3,6,2,8,4,9,5];
            const arr2 = ['홍길동', '김말똥', '이적삼', '박말자', '나다영'];

            // 기존의 배열 구조 출력
            divEl.innerHTML = "기존 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "기존 arr2 : " + arr2 + "<br>";

            // sort요소를 활용하여 배열들 오름차순으로 정렬하기
            divEl.innerHTML += "<br>오름차순 arr1 : " + arr1.sort() + "<br>";
            divEl.innerHTML += "오름차순 arr2 : " + arr2.sort() + "<br>";

            // 정렬 후의 배열들 출력
            divEl.innerHTML += "<br>정렬 후 arr1 : " + arr1 + "<br>";
            divEl.innerHTML += "정렬 후 arr2 : " + arr2 + "<br>";
            // 배열들이 오름차순으로 고정되어서 나열됨
            // 즉, sort요소는 원본에 영향을 끼치는 메소드 => 내림차순을 하고싶으면 오름차순으로 정렬된 배열에 reverse를 추가해주면 됨!

            // 내림차순으로 정렬하기
            divEl.innerHTML += "<br>내림차순 arr1 : " + arr1.reverse() + "<br>";
            divEl.innerHTML += "내림차순 arr2 : " + arr2.reverse() + "<br>";

        }

    </script>
    
    <hr>

    <h4>
        5_1) 배열.push(추가할 요소) : 배열의 "맨 뒤에 요소 추가"시켜주고 배열의 크기 반환<br>
        5_2) 배열.pop() : 배열의 "맨 뒤 요소를 제거"시키고 제거된 요소 반환
    </h4>
    <div class="area" id="area6"></div>
    <button onclick="pushPopTest();">배열 맨 뒤 확인하기</button>

    <script>

        function pushPopTest() {

            // div요소에 담기
            const divEl = document.getElementById('area6');

            // 임의의 배열 생성
            const arr = ['홍길동', '김말똥', '이적삼', '박말자', '나다영'];

            // 기존의 배열 출력하기
            divEl.innerHTML = "기존의 arr : " + arr + "<br>";
            divEl.innerHTML += "기존 배열의 크기 : " + arr.length + "<br>";

            // push를 통해 배열 맨 뒤에 요소 추가하기
            divEl.innerHTML += "push적용 후의 arr : " + arr.push('최나라') + "<br>"; // 배열의 크기 반환해줌
            divEl.innerHTML += "arr에 추가된 요소 : " + arr[5] + "<br>";

            // pop을 통해 배열 맨 뒤 요소 제거하기
            divEl.innerHTML += "<br>pop을 통해 제거된 요소1 : " + arr.pop() + "<br>";
            divEl.innerHTML += "pop을 통해 제거된 요소2 : " + arr.pop() + "<br>";
            divEl.innerHTML += "pop을 통해 제거된 요소3 : " + arr.pop() + ", " + arr.pop() +"<br>";
            divEl.innerHTML += "최종 arr : " + arr + "<br>";
            // push, pop : 원본배열에 영향을 끼치는 메소드
            
        }
    </script>

    <hr>

    <h4>
        6_1) 배열.unshift(추가할요소) : 배열의 "맨 앞에 요소 추가" 후 배열의 크기 반환 <br>
        6_2) 배열.shift() : 배열의 "맨 앞의 요소 제거" 후 제거된 요소 반환
    </h4>

    <div class="area" id="area7"></div>
    <button onclick="shiftUnshiftTest();">배열 맨 앞 확인하기</button>

    <script>

        function shiftUnshiftTest() {

            // div요소에 담기
            const divEl = document.getElementById('area7');

            // 임의의 배열 생성
            const arr = ['홍길동', '김말똥', '이적삼', '박말자', '나다영'];

            // 기존의 배열 출력
            divEl.innerHTML = "기존의 arr : " + arr + "<br>";
            divEl.innerHTML += "기존 arr의 크기 : " + arr.length + "<br>";

            // Unshift를 통해 배열 맨 앞에 요소 추가하기
            divEl.innerHTML += "unshift 적용 후의 arr의 크기 : " + arr.unshift("최나라") + "<br>";
            divEl.innerHTML += "추가 된 후의 arr : " + arr + "<br>"; // '최나라' 추가됨

            // shift를 통해 배열 맨 앞에 요소 제거하기
            divEl.innerHTML += "<br>shift 적용 후의 제거하는 arr의 요소 : " + arr.shift() + ", " + arr.shift() + "<br>";
            divEl.innerHTML += "최종 arr : " + arr + "<br>";
            // unshift, shift : 원본에 영향을 끼치는 메소드

            // const로 선언된 변수는 메소드의 의해서 내부적으로 변경은 가능하지만
            // arr = []; // 처럼 재할당을 통해 값 자체를 변화시키는 것은 불가능함

        }

    </script>

    <hr>

    <h4>
        7_1) 배열.slice(시작인덱스, 끝인덱스) : 배열의 시작인덱스에서부터 끝 인덱스까지 단지 추출해서 새로운 배열로 반환해주는 메소드 <br>
        <!-- 원본배열에서 추출된 요소를 제거 x => 단지 추출해서 출력만함 ==> 원본에 영향을 끼치지않는 메소드 -->
        7_2) 배열.splice(시작인덱스, 끝인덱스, [추가할 값]) : 해당 배열의 요소를 추출해서 제거 및 추가해주는 메소드
        <!-- 원본배열에서 추출된 요소를 제거 및 새로운 값을 추가 ==> 원본에 영향을 끼치는 메소드 -->
    </h4>

    <div class="area" id="area8"></div>
    <button onclick="sliceSpliceTest();">추출 확인하기</button>

    <script>

        function sliceSpliceTest() {

            // div요소에 담기
            const divEl = document.getElementById('area8');

            // 임의의 배열 생성
            const arr = ['홍길동', '김말똥', '이적삼', '박말자', '나다영'];

            // 기존의 배열 출력
            divEl.innerHTML = "기존의 arr : " + arr + "<br>";

            // slice를 통해서 값 추출하기
            divEl.innerHTML += "slice 결과 : " + arr.slice(1,4) + "<br>";
            // 시작인덱스 : 1, 끝인덱스 : 3 => 끝인덱스는 제시한 (끝인덱스-1) 로 반환됨
            
            // slice한 후의 배열 출력
            divEl.innerHTML += "slice 후의 arr : " + arr + "<br>";
            // 원본 그대로 추출됨 => 원본에 영향을 끼치지 않는 메소드

            // splice를 통해서 값 추출하기
            divEl.innerHTML += "splice 결과 : " + arr.splice(0,2) + "<br>";
            // 시작인덱스 : 0, 끝인덱스 : 1 => 끝인덱스는 제시한 (끝인덱스-1) 로 반환됨
            divEl.innerHTML += "splice 후의 arr : " + arr + "<br>";
            // splice로 추출한 값들이 제거되고 남은 값들이 출력됨 => 원본에 영향을 끼치는 메소드

            // splice를 통해서 값 추출한 후 새로운 값 추가하기
            divEl.innerHTML += "<br>splice 적용 : " + arr.splice(1,3,'파바람', '노홍칙') + "<br>";
            // 시작인덱스 : 1, 끝인덱스 : 2 => 끝인덱스는 제시한 (끝인덱스-1) 로 반환됨
            divEl.innerHTML += "splice 적용 후의 arr : " + arr + "<br>";
            // splice로 추출한 값들은 제거되고 새로운 값들이 추가된 것을 확인

        }

    </script>

    <hr>

    <h4>
        8) 배열.toString() / 배열.join([구분자]) <br>
            공통점 : 배열에 각 인덱스에 담긴 값들을 하나의 "문자열"로 합쳐서 반환 <br>
            차이점 : join은 구분자를 직접 지정할 수 있지만 toString은 지정할 수 없다.
    </h4>
    <div class="area" id="area9"></div>
    <button onclick="toStringJoinTest();">배열 확인하기</button>

    <script>

        function toStringJoinTest() {

            // div요소에 담기
            divEl = document.getElementById('area9');

            // 임의의 배열 생성
            const arr = ['Java', 'Oracle', 'HTML', 'CSS', 'JavaScript'];

            // 기존 배열 출력하기
            divEl.innerHTML = "arr : " + arr/*toString()*/ + "<br>"; // toString값이 내부적으로 생략되어있음
            // toString으로 배열 출력하기
            divEl.innerHTML += "toString : " + arr.toString() + "<br>";
            // 기존 출력문과 toString을 통해 출력했을 때의 결과는 동일하다
            // => 자바스크립트에서 객체를 화면에 출력하면 내부적으로 객체.toString() 호출한 결과가 출력

            // join으로 배열 출력하기
            divEl.innerHTML += "join : " + arr.join() + "<br>";
            divEl.innerHTML += "join() : " + arr.join('/') + "<br>";

        }

    </script>

    <br><br><br>
</body>

</html>